# Migration Guide to @sentzunhat/zacatl v0.0.20

This guide helps you upgrade your existing project to use the new modular, type-safe infrastructure in v0.0.20.

## What's New in v0.0.20

### ‚ú® Major Improvements

1. **Type-Safe ORM Selection** - Use `ORMType` enum instead of string literals
2. **Zero `any` Casts** - Full type safety with proper type guards
3. **Modular ORM Architecture** - Clean separation between adapters and repositories
4. **Multi-Database Support** - Run MongoDB + PostgreSQL + SQLite simultaneously
5. **Simplified Repository Pattern** - One `BaseRepository` for all ORMs
6. **üéâ Single Package Import** - Import mongoose, sequelize, zod, tsyringe from `@sentzunhat/zacatl` (see [SINGLE_IMPORT_GUIDE.md](./examples/SINGLE_IMPORT_GUIDE.md))

### üîß Breaking Changes

- Repository configuration now requires `ORMType` enum instead of string literals
- Removed duplicate `MongooseRepository` and `SequelizeRepository` classes
- All repositories must extend `BaseRepository`

---

## Migration Checklist

### Step 1: Update Package Version

```bash
npm install @sentzunhat/zacatl@0.0.20
# or
yarn add @sentzunhat/zacatl@0.0.20
```

### Step 2: Update Repository Imports

#### Before (v0.0.19 and earlier)

```typescript
import { MongooseRepository } from "@sentzunhat/zacatl/infrastructure/repositories";
import { SequelizeRepository } from "@sentzunhat/zacatl/infrastructure/repositories";
```

#### After (v0.0.20)

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl/infrastructure";
```

### Step 3: Update Repository Classes

#### Mongoose Repositories

**Before:**

```typescript
import { MongooseRepository } from "@sentzunhat/zacatl";
import { Schema } from "mongoose";

interface UserDb {
  username: string;
  email: string;
}

const UserSchema = new Schema<UserDb>(
  {
    username: { type: String, required: true },
    email: { type: String, required: true },
  },
  { timestamps: true },
);

export class UserRepository extends MongooseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({
      type: "mongoose", // ‚ùå String literal
      name: "User",
      schema: UserSchema,
    });
  }
}
```

**After:**

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl";
import { Schema } from "mongoose";

interface UserDb {
  username: string;
  email: string;
}

const UserSchema = new Schema<UserDb>(
  {
    username: { type: String, required: true },
    email: { type: String, required: true },
  },
  { timestamps: true },
);

export class UserRepository extends BaseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({
      type: ORMType.Mongoose, // ‚úÖ Type-safe enum
      name: "User",
      schema: UserSchema,
    });
  }
}
```

#### Sequelize Repositories

**Before:**

```typescript
import { SequelizeRepository } from "@sentzunhat/zacatl";
import { Model, DataTypes, Sequelize } from "sequelize";

class ProductModel extends Model {}

export class ProductRepository extends SequelizeRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({
      type: "sequelize", // ‚ùå String literal
      model: ProductModel,
    });
  }
}
```

**After:**

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl";
import { Model, DataTypes, Sequelize } from "sequelize";

class ProductModel extends Model {}

export class ProductRepository extends BaseRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({
      type: ORMType.Sequelize, // ‚úÖ Type-safe enum
      model: ProductModel,
    });
  }
}
```

### Step 4: Update Service Configuration

No changes needed! Your existing service configuration works as-is:

```typescript
import { Service, DatabaseVendor } from "@sentzunhat/zacatl";
import { UserRepository } from "./repositories/user.repository";
import { ProductRepository } from "./repositories/product.repository";

const service = new Service({
  architecture: {
    infrastructure: {
      repositories: [UserRepository, ProductRepository], // ‚úÖ Still works
    },
    domain: {
      providers: [],
    },
    server: {
      name: "my-service",
      databases: [
        {
          vendor: DatabaseVendor.MONGOOSE,
          instance: mongooseInstance,
          connectionString: "mongodb://localhost:27017",
        },
      ],
    },
  },
});
```

### Step 5: Find and Replace Across Your Project

Use your editor's find-and-replace:

1. **Find:** `type: "mongoose"`  
   **Replace:** `type: ORMType.Mongoose`

2. **Find:** `type: "sequelize"`  
   **Replace:** `type: ORMType.Sequelize`

3. **Find:** `extends MongooseRepository`  
   **Replace:** `extends BaseRepository`

4. **Find:** `extends SequelizeRepository`  
   **Replace:** `extends BaseRepository`

5. **Find:** `import { MongooseRepository`  
   **Replace:** `import { BaseRepository, ORMType`

6. **Find:** `import { SequelizeRepository`  
   **Replace:** `import { BaseRepository, ORMType`

### Step 6: Update Import Paths (if needed)

Ensure you're importing from the correct paths:

```typescript
// Main exports
import {
  Service,
  DatabaseVendor,
  ServerVendor,
  ServerType,
} from "@sentzunhat/zacatl";

// Infrastructure exports
import { BaseRepository, ORMType } from "@sentzunhat/zacatl/infrastructure";

// Error exports
import {
  CustomError,
  BadRequestError,
  NotFoundError,
} from "@sentzunhat/zacatl/error";

// Localization exports
import { Localization } from "@sentzunhat/zacatl/localization";
```

### Step 7: Build and Test

```bash
# Build your project
npm run build

# Run tests
npm test

# Check for TypeScript errors
npx tsc --noEmit
```

---

## Common Migration Scenarios

### Scenario 1: Project Using Only Mongoose

**Before:**

```typescript
import { MongooseRepository } from "@sentzunhat/zacatl";

export class UserRepository extends MongooseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: "mongoose", name: "User", schema: UserSchema });
  }
}

export class PostRepository extends MongooseRepository<
  PostDb,
  PostInput,
  PostOutput
> {
  constructor() {
    super({ type: "mongoose", name: "Post", schema: PostSchema });
  }
}
```

**After:**

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl";

export class UserRepository extends BaseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: ORMType.Mongoose, name: "User", schema: UserSchema });
  }
}

export class PostRepository extends BaseRepository<
  PostDb,
  PostInput,
  PostOutput
> {
  constructor() {
    super({ type: ORMType.Mongoose, name: "Post", schema: PostSchema });
  }
}
```

### Scenario 2: Project Using Only Sequelize

**Before:**

```typescript
import { SequelizeRepository } from "@sentzunhat/zacatl";

export class UserRepository extends SequelizeRepository<
  UserModel,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: "sequelize", model: UserModel });
  }
}

export class ProductRepository extends SequelizeRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({ type: "sequelize", model: ProductModel });
  }
}
```

**After:**

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl";

export class UserRepository extends BaseRepository<
  UserModel,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: ORMType.Sequelize, model: UserModel });
  }
}

export class ProductRepository extends BaseRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({ type: ORMType.Sequelize, model: ProductModel });
  }
}
```

### Scenario 3: Mixed ORM Project

**Before:**

```typescript
import { MongooseRepository, SequelizeRepository } from "@sentzunhat/zacatl";

// MongoDB for users
export class UserRepository extends MongooseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: "mongoose", name: "User", schema: UserSchema });
  }
}

// PostgreSQL for products
export class ProductRepository extends SequelizeRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({ type: "sequelize", model: ProductModel });
  }
}
```

**After:**

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl";

// MongoDB for users
export class UserRepository extends BaseRepository<
  UserDb,
  UserInput,
  UserOutput
> {
  constructor() {
    super({ type: ORMType.Mongoose, name: "User", schema: UserSchema });
  }
}

// PostgreSQL for products
export class ProductRepository extends BaseRepository<
  ProductModel,
  ProductInput,
  ProductOutput
> {
  constructor() {
    super({ type: ORMType.Sequelize, model: ProductModel });
  }
}
```

---

## New Features You Can Now Use

### 1. Multiple Databases Simultaneously

```typescript
const service = new Service({
  architecture: {
    infrastructure: {
      repositories: [
        UserRepository, // Mongoose ‚Üí MongoDB
        SessionRepository, // Mongoose ‚Üí MongoDB
        ProductRepository, // Sequelize ‚Üí PostgreSQL
        OrderRepository, // Sequelize ‚Üí PostgreSQL
        CacheRepository, // Sequelize ‚Üí SQLite
      ],
    },
    server: {
      databases: [
        {
          vendor: DatabaseVendor.MONGOOSE,
          instance: new mongoose.Mongoose(),
          connectionString: "mongodb://localhost:27017",
        },
        {
          vendor: DatabaseVendor.SEQUELIZE,
          instance: new Sequelize("postgres://localhost:5432/products"),
          connectionString: "postgres://localhost:5432/products",
        },
        {
          vendor: DatabaseVendor.SEQUELIZE,
          instance: new Sequelize({ dialect: "sqlite", storage: "./cache.db" }),
          connectionString: "",
        },
      ],
    },
  },
});
```

### 2. SQLite for Development/Testing

```typescript
// Development: Use SQLite for fast local development
const devDb = new Sequelize({ dialect: "sqlite", storage: ":memory:" });

// Production: Use PostgreSQL
const prodDb = new Sequelize(process.env.DATABASE_URL);

const databases =
  process.env.NODE_ENV === "production"
    ? [
        {
          vendor: DatabaseVendor.SEQUELIZE,
          instance: prodDb,
          connectionString: process.env.DATABASE_URL,
        },
      ]
    : [
        {
          vendor: DatabaseVendor.SEQUELIZE,
          instance: devDb,
          connectionString: "",
        },
      ];
```

### 3. Type-Safe Configuration

```typescript
// ‚úÖ TypeScript autocomplete works
super({ type: ORMType.Mongoose, ... });

// ‚ùå Compile error on typo
super({ type: ORMType.Mongoos, ... }); // Error: Property 'Mongoos' does not exist

// ‚ùå Compile error on wrong config
super({ type: ORMType.Mongoose, model: ... }); // Error: 'model' is not valid for Mongoose
```

---

## Troubleshooting

### Error: `Cannot find name 'ORMType'`

**Solution:** Add the import:

```typescript
import { BaseRepository, ORMType } from "@sentzunhat/zacatl/infrastructure";
```

### Error: `MongooseRepository is not exported`

**Solution:** `MongooseRepository` was removed. Use `BaseRepository` instead:

```typescript
// Before
import { MongooseRepository } from "@sentzunhat/zacatl";
export class MyRepo extends MongooseRepository<D, I, O> {}

// After
import { BaseRepository } from "@sentzunhat/zacatl";
export class MyRepo extends BaseRepository<D, I, O> {}
```

### Error: `Type '"mongoose"' is not assignable to type 'ORMType'`

**Solution:** Use the enum:

```typescript
// Before
super({ type: "mongoose", ... });

// After
super({ type: ORMType.Mongoose, ... });
```

### TypeScript Errors After Migration

1. Delete `node_modules` and reinstall:

   ```bash
   rm -rf node_modules package-lock.json
   npm install
   ```

2. Clear TypeScript cache:

   ```bash
   rm -rf dist build .tsbuildinfo
   npm run build
   ```

3. Restart your IDE/editor

---

## Automated Migration Script

Save this as `migrate-to-v0.0.20.sh`:

```bash
#!/bin/bash
# Migration script for @sentzunhat/zacatl v0.0.20

echo "üöÄ Starting migration to v0.0.20..."

# Update package version
echo "üì¶ Updating package..."
npm install @sentzunhat/zacatl@0.0.20

# Find and replace in TypeScript files
echo "üîÑ Updating repository types..."

# Replace imports
find src -type f -name "*.ts" -exec sed -i '' 's/MongooseRepository/BaseRepository/g' {} +
find src -type f -name "*.ts" -exec sed -i '' 's/SequelizeRepository/BaseRepository/g' {} +

# Replace type strings with enums
find src -type f -name "*.ts" -exec sed -i '' 's/type: "mongoose"/type: ORMType.Mongoose/g' {} +
find src -type f -name "*.ts" -exec sed -i '' 's/type: "sequelize"/type: ORMType.Sequelize/g' {} +

# Add ORMType import where BaseRepository is imported
find src -type f -name "*.ts" -exec sed -i '' 's/import { BaseRepository }/import { BaseRepository, ORMType }/g' {} +

echo "‚úÖ Migration complete!"
echo "‚ö†Ô∏è  Please review changes and run: npm run build"
```

Make it executable:

```bash
chmod +x migrate-to-v0.0.20.sh
./migrate-to-v0.0.20.sh
```

---

## Quick Reference

### Import Map

| Old Import            | New Import           |
| --------------------- | -------------------- |
| `MongooseRepository`  | `BaseRepository`     |
| `SequelizeRepository` | `BaseRepository`     |
| N/A                   | `ORMType` (new enum) |

### Type Map

| Old Type            | New Type                  |
| ------------------- | ------------------------- |
| `type: "mongoose"`  | `type: ORMType.Mongoose`  |
| `type: "sequelize"` | `type: ORMType.Sequelize` |

### Available ORMType Values

```typescript
enum ORMType {
  Mongoose = "mongoose", // MongoDB
  Sequelize = "sequelize", // PostgreSQL, MySQL, SQLite, MariaDB, MSSQL
}
```

### Available DatabaseVendor Values

```typescript
enum DatabaseVendor {
  MONGOOSE = "MONGOOSE", // MongoDB
  SEQUELIZE = "SEQUELIZE", // SQL databases
}
```

---

## Support

- **Documentation:** [docs/examples/INFRASTRUCTURE_USAGE.md](./examples/INFRASTRUCTURE_USAGE.md)
- **Multi-ORM Setup:** [docs/examples/MULTI_ORM_SETUP.md](./examples/MULTI_ORM_SETUP.md)
- **Type Safety:** [docs/examples/TYPE_SAFETY_IMPROVEMENTS.md](./examples/TYPE_SAFETY_IMPROVEMENTS.md)

---

## Summary

**v0.0.20 brings:**

- ‚úÖ Better type safety (no more `any` casts)
- ‚úÖ Cleaner architecture (one `BaseRepository` for all ORMs)
- ‚úÖ Enum-based configuration (`ORMType` enum)
- ‚úÖ Multi-database support out of the box
- ‚úÖ Easier testing with SQLite

**Migration time:** ~5-15 minutes for most projects

**Main changes:**

1. Replace `MongooseRepository` ‚Üí `BaseRepository`
2. Replace `SequelizeRepository` ‚Üí `BaseRepository`
3. Replace `type: "mongoose"` ‚Üí `type: ORMType.Mongoose`
4. Replace `type: "sequelize"` ‚Üí `type: ORMType.Sequelize`
5. Import `ORMType` enum

That's it! Your project is now ready for v0.0.20! üéâ
