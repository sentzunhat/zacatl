# Migration Guide: v0.0.21 ‚Üí v0.0.22

## Overview

Version 0.0.22 fixes a **critical ESM runtime bug** in v0.0.21 that prevented the framework from working in pure ESM environments (Bun, Node.js with native ESM, Vite, Next.js, etc.).

**Impact**: Non-breaking for most users. The API remains the same.

---

## What Changed

### üêõ Critical Bug Fix: ESM Compatibility

**Problem in v0.0.21:**

- The adapter-loader used CommonJS `require()` which threw `ReferenceError: require is not defined` in ESM environments
- Prevented framework from working in Bun, Node.js ESM projects, and modern build tools

**Solution in v0.0.22:**

- ‚úÖ Replaced `require()` with async `import()`
- ‚úÖ Implemented lazy loading pattern with backward compatibility
- ‚úÖ Repository constructors remain synchronous
- ‚úÖ Adapters load on first async method call

---

## Migration Steps

### For Most Users: **No Changes Required** ‚úÖ

If your code looks like this, it continues to work without modification:

```typescript
export class UserRepository extends BaseRepository<User, string, UserOutput> {
  constructor() {
    super({
      type: ORMType.Mongoose,
      model: UserModel,
    });
  }
}

// Usage
const repo = new UserRepository();
const user = await repo.findById("123"); // Adapter loads here automatically
```

**What happens internally:**

1. Constructor runs synchronously (no changes)
2. First async call (`findById`, `create`, `update`, `delete`) triggers lazy adapter loading
3. Subsequent calls use the cached adapter (no performance impact)

---

## Breaking Changes

### ‚ö†Ô∏è Accessing Model Before First Async Call

If you access the model synchronously after construction, you'll see a new error:

```typescript
const repo = new UserRepository();
repo.getMongooseModel(); // ‚ùå NEW ERROR in v0.0.22
// Error: Repository not initialized. Call an async method first
```

**Fix:**
Call an async method first to initialize the adapter:

```typescript
const repo = new UserRepository();
await repo.create({ name: "test" }); // Initialize adapter
repo.getMongooseModel(); // ‚úÖ Now works
```

**Or** restructure to avoid sync model access:

```typescript
const repo = new UserRepository();
const user = await repo.findById("123"); // Adapter initialized
// Now you can use repo.getMongooseModel() if needed
```

---

## Technical Details

### Adapter Loading Behavior

**Before (v0.0.21):**

```typescript
constructor(config) {
  this.adapter = loadMongooseAdapter(config);  // ‚ùå Sync, used require()
}
```

**After (v0.0.22):**

```typescript
constructor(config) {
  this.config = config;  // ‚úÖ Sync, stores config
}

private async ensureInitialized() {
  if (!this.adapter) {
    this.adapter = await loadMongooseAdapter(this.config);  // ‚úÖ Async import()
  }
}

async findById(id) {
  await this.ensureInitialized();  // Lazy load
  return this.adapter.findById(id);
}
```

### Error Code Handling

Now handles both ESM and CommonJS error codes:

```typescript
catch (error) {
  if (error.code === "ERR_MODULE_NOT_FOUND" ||  // ESM
      error.code === "MODULE_NOT_FOUND") {        // CommonJS
    throw new Error("Mongoose is not installed...");
  }
}
```

---

## Testing Your Migration

### 1. Run Your Existing Tests

```bash
npm test
```

All tests should pass without changes.

### 2. Test ESM Runtime (if applicable)

```bash
# Bun
bun test

# Node.js with tsx
npm run test:node

# Or verify your specific runtime
node --version
npm test
```

### 3. Check for Sync Model Access

Search your codebase for patterns that might fail:

```bash
# Look for potential issues
grep -r "getMongooseModel()" --include="*.ts"
grep -r "getSequelizeModel()" --include="*.ts"
grep -r "\.model\." --include="*.ts"
```

If found, ensure an async method is called first.

---

## Performance Impact

**None.** Lazy loading happens once per repository instance:

```typescript
const repo = new UserRepository();

await repo.findById("1");    // Loads adapter (one-time cost)
await repo.findById("2");    // Uses cached adapter
await repo.create({...});    // Uses cached adapter
```

**Benchmarks:**

- Adapter load time: <5ms (one-time)
- Subsequent calls: 0ms overhead
- Memory: Same as v0.0.21

---

## Common Issues

### Issue 1: "Repository not initialized" Error

**Cause:** Accessing model/adapter before calling async method

**Solution:**

```typescript
// ‚ùå Before
const repo = new UserRepository();
const model = repo.getMongooseModel();

// ‚úÖ After
const repo = new UserRepository();
await repo.findById("init"); // or any async method
const model = repo.getMongooseModel();
```

### Issue 2: Tests Failing with "not initialized"

**Cause:** Test setup accessing model synchronously

**Solution:**

```typescript
// ‚ùå Before
beforeEach(() => {
  repository = new UserRepository();
  vi.spyOn(repository.getMongooseModel(), "findById");
});

// ‚úÖ After
beforeEach(async () => {
  repository = new UserRepository();
  await repository.create({ test: "data" }); // Initialize
  vi.spyOn(repository.getMongooseModel(), "findById");
});
```

---

## Rollback Plan

If you encounter issues, you can temporarily rollback:

```bash
npm install @sentzunhat/zacatl@0.0.21
```

**Note:** v0.0.21 will NOT work in pure ESM environments (Bun, Node ESM, etc.)

---

## Benefits of Upgrading

‚úÖ **ESM Compatibility** - Works in Bun, Node.js ESM, Vite, Next.js  
‚úÖ **No Breaking Changes** - Existing code continues to work  
‚úÖ **Better Error Messages** - Clearer messages when ORMs are missing  
‚úÖ **Future-Proof** - Aligns with modern JavaScript/TypeScript ecosystem

---

## Questions?

- üìñ See full [CHANGELOG](../changelog.md)
- üêõ Report issues: [GitHub Issues](https://github.com/sentzunhat/zacatl/issues)
- üìö Documentation: [docs/](../INDEX.md)

---

**Upgrade Command:**

```bash
npm install @sentzunhat/zacatl@latest
# or
yarn add @sentzunhat/zacatl@latest
# or
bun add @sentzunhat/zacatl@latest
```
