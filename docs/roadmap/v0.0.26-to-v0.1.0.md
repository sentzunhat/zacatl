# Migration Guide: v0.0.26 to v0.1.0

## Overview

Version v0.1.0 introduces multi-context architecture support, allowing zacatl to power CLI tools, Desktop applications, and HTTP servers from a unified codebase. This guide helps you migrate existing code to the new structure.

---

## Breaking Changes

### 1. Property Name Changes

**Application Layer Properties** have been renamed for clarity:

| Old Name                   | New Name            | Type                               |
| -------------------------- | ------------------- | ---------------------------------- |
| `hookHandlers`             | `hooks`             | `Array<Constructor<HookHandler>>`  |
| `routeHandlers`            | `routes`            | `Array<Constructor<RouteHandler>>` |
| `ApplicationHookHandlers`  | `ApplicationHooks`  | Type alias                         |
| `ApplicationRouteHandlers` | `ApplicationRoutes` | Type alias                         |

### 2. Config Structure Changes

**ApplicationEntryPoints** is now polymorphic:

```typescript
// Before (v0.0.26)
export type ApplicationEntryPoints = {
  rest: {
    hookHandlers: ApplicationHookHandlers;
    routeHandlers: ApplicationRouteHandlers;
  };
};

// After (v0.1.0)
export type ApplicationEntryPoints = {
  cli?: {
    commands: Array<Constructor<Command>>;
  };
  rest?: {
    hooks: ApplicationHooks;
    routes: ApplicationRoutes;
  };
  ipc?: {
    handlers: Array<Constructor<IPCHandler>>;
  };
};
```

### 3. Service Type Declaration

**ConfigService** now includes an optional `type` field:

```typescript
// Before (v0.0.26)
const service = new Service({
  architecture: {
    application: { ... },
    domain: { ... },
    infrastructure: { ... },
    server: { ... },
  },
});

// After (v0.1.0)
const service = new Service({
  type: ServiceType.SERVER, // NEW: Explicit type (optional, defaults to SERVER)
  architecture: {
    application: { ... },
    domain: { ... },
    infrastructure: { ... },
    server: { ... },
  },
});
```

---

## Migration Scenarios

### Scenario 1: HTTP Server (No Changes Needed)

If you're using zacatl for an HTTP server and **don't specify a type**, everything continues to work:

**Before (v0.0.26)**:

```typescript
import { Service, ServerVendor } from "@sentzunhat/zacatl";

const service = new Service({
  architecture: {
    application: {
      entryPoints: {
        rest: {
          hookHandlers: [AuthHook],
          routeHandlers: [UserRoute],
        },
      },
    },
    domain: { providers: [UserProvider] },
    infrastructure: { repositories: [UserRepository] },
    server: { vendor: ServerVendor.FASTIFY },
  },
});

await service.start({ port: 3000 });
```

**After (v0.1.0)** - Still works! But with deprecation warnings:

```typescript
import { Service, ServerVendor } from "@sentzunhat/zacatl";

const service = new Service({
  // type: ServiceType.SERVER, // Optional: defaults to SERVER
  architecture: {
    application: {
      entryPoints: {
        rest: {
          hookHandlers: [AuthHook], // ⚠️ Still works via legacy getter
          routeHandlers: [UserRoute], // ⚠️ Still works via legacy getter
        },
      },
    },
    domain: { providers: [UserProvider] },
    infrastructure: { repositories: [UserRepository] },
    server: { vendor: ServerVendor.FASTIFY },
  },
});

await service.start({ port: 3000 });
```

### Scenario 2: HTTP Server (Recommended Migration)

Update your config to use the new property names:

```typescript
import { Service, ServiceType, ServerVendor } from "@sentzunhat/zacatl";

const service = new Service({
  type: ServiceType.SERVER, // NEW: Explicit type declaration
  architecture: {
    application: {
      entryPoints: {
        rest: {
          hooks: [AuthHook], // UPDATED: hookHandlers → hooks
          routes: [UserRoute], // UPDATED: routeHandlers → routes
        },
      },
    },
    domain: { providers: [UserProvider] },
    infrastructure: { repositories: [UserRepository] },
    server: { vendor: ServerVendor.FASTIFY },
  },
});

await service.start({ port: 3000 });
```

### Scenario 3: CLI Application (New)

Create a CLI application using the new multi-context support:

```typescript
import { Service, ServiceType } from "@sentzunhat/zacatl";

const service = new Service({
  type: ServiceType.CLI,
  architecture: {
    application: {
      entryPoints: {
        cli: {
          commands: [DeployCommand, StatusCommand, HelpCommand],
        },
      },
    },
    domain: { providers: [DeploymentProvider, ConfigProvider] },
    infrastructure: { repositories: [ConfigRepository] },
    cli: {
      name: "ujti",
      version: "2.0.0",
      description: "Infrastructure automation CLI",
    },
  },
});

await service.start();
```

### Scenario 4: Desktop Application (New)

Create a desktop application:

```typescript
import { Service, ServiceType } from "@sentzunhat/zacatl";

const service = new Service({
  type: ServiceType.DESKTOP,
  architecture: {
    application: {
      entryPoints: {
        ipc: {
          handlers: [FileHandler, WindowHandler, DBHandler],
        },
      },
    },
    domain: { providers: [FileProvider, WindowProvider] },
    infrastructure: { repositories: [SettingsRepository] },
    desktop: {
      window: {
        title: "My App",
        width: 1024,
        height: 768,
        resizable: true,
      },
      platform: "neutralino",
    },
  },
});

await service.start();
```

---

## Step-by-Step Migration

### Step 1: Update Imports

Add new type imports if you want explicit type declarations:

```typescript
// Add to existing imports
import {
  Service,
  ServiceType, // NEW
  ConfigCLI, // NEW (if using CLI)
  ConfigDesktop, // NEW (if using Desktop)
  ApplicationHooks, // NEW (replaces ApplicationHookHandlers)
  ApplicationRoutes, // NEW (replaces ApplicationRouteHandlers)
} from "@sentzunhat/zacatl";
```

### Step 2: Update Type Aliases (Optional)

If you've created type aliases using the old names:

```typescript
// Before
type MyHooks = ApplicationHookHandlers;
type MyRoutes = ApplicationRouteHandlers;

// After
type MyHooks = ApplicationHooks;
type MyRoutes = ApplicationRoutes;
```

### Step 3: Update Config Property Names

Replace old property names in your config:

```typescript
// Before
entryPoints: {
  rest: {
    hookHandlers: [...],
    routeHandlers: [...],
  },
}

// After
entryPoints: {
  rest: {
    hooks: [...],
    routes: [...],
  },
}
```

### Step 4: Add Type Declaration (Recommended)

Explicitly declare your service type:

```typescript
const service = new Service({
  type: ServiceType.SERVER, // or CLI, or DESKTOP
  architecture: {
    // ... rest of config
  },
});
```

### Step 5: Run Tests

Ensure all tests pass after migration:

```bash
npm test
```

---

## Backward Compatibility

### Legacy Getter Support

The Application class provides legacy getters for backward compatibility:

```typescript
// These still work (but are deprecated)
application.hookHandlers; // Returns application.hooks
application.routeHandlers; // Returns application.routes
```

### Default Service Type

If you don't specify a `type`, it defaults to `ServiceType.SERVER`:

```typescript
// These are equivalent:
new Service({ architecture: { ... } });
new Service({ type: ServiceType.SERVER, architecture: { ... } });
```

### Validation

Type-specific validation ensures configs match the declared type:

```typescript
// ❌ This will throw an error:
new Service({
  type: ServiceType.CLI,
  architecture: {
    // Missing cli config!
    application: { entryPoints: { rest: { ... } } }, // Wrong entry points!
  },
});

// ✅ This is correct:
new Service({
  type: ServiceType.CLI,
  architecture: {
    cli: { name: "my-cli", version: "1.0.0" },
    application: { entryPoints: { cli: { commands: [...] } } },
  },
});
```

---

## Common Migration Issues

### Issue 1: "Cannot read properties of undefined (reading 'rest')"

**Cause**: Application config is missing entryPoints

**Fix**: Add entryPoints to your application config:

```typescript
application: {
  entryPoints: {
    rest: {
      hooks: [...],
      routes: [...],
    },
  },
}
```

### Issue 2: "ServiceType.SERVER requires 'architecture.server' configuration"

**Cause**: Type is set to SERVER but server config is missing

**Fix**: Add server config or change type:

```typescript
// Option 1: Add server config
server: {
  vendor: ServerVendor.FASTIFY;
}

// Option 2: Remove type (defaults to SERVER, triggers same error)
// Option 3: Change to CLI or DESKTOP type
```

### Issue 3: Tests failing with "dependencies is not iterable"

**Cause**: Tests using old property names

**Fix**: Update test configs to use new names:

```typescript
// Before
entryPoints: {
  rest: {
    hookHandlers: [TestHook],
    routeHandlers: [TestRoute],
  },
}

// After
entryPoints: {
  rest: {
    hooks: [TestHook],
    routes: [TestRoute],
  },
}
```

---

## New Features

### ServiceType Enum

```typescript
export enum ServiceType {
  CLI = "CLI",
  DESKTOP = "DESKTOP",
  SERVER = "SERVER",
}
```

### ConfigCLI Type

```typescript
export type ConfigCLI = {
  name: string; // CLI command name
  version: string; // CLI version
  description?: string; // Help text
};
```

### ConfigDesktop Type

```typescript
export type ConfigDesktop = {
  window: {
    title: string;
    width: number;
    height: number;
    resizable?: boolean;
    minWidth?: number;
    minHeight?: number;
  };
  platform: "neutralino" | "electron";
};
```

---

## Timeline

- **v0.0.26**: Current stable version
- **v0.1.0**: Multi-context support with backward compatibility
- **v0.2.0**: CLI implementation complete
- **v0.3.0**: Desktop implementation complete
- **v1.0.0**: Deprecation warnings removed, legacy getters removed

---

## Getting Help

- Review the [Multi-Context Cleanup Design](../architecture/MULTI-CONTEXT-CLEANUP-DESIGN.md)
- Check the [examples](../examples/) directory
- Open an issue on GitHub

---

## Summary

**Minimal Migration** (no code changes needed):

- Keep using old property names (legacy getters handle it)
- Don't specify `type` (defaults to SERVER)
- Tests should pass without changes

**Recommended Migration** (future-proof):

- Rename `hookHandlers` → `hooks`
- Rename `routeHandlers` → `routes`
- Add `type: ServiceType.SERVER` explicitly
- Update type imports

**New Features** (opt-in):

- Use `ServiceType.CLI` for CLI apps
- Use `ServiceType.DESKTOP` for desktop apps
- Configure with `ConfigCLI` or `ConfigDesktop`
